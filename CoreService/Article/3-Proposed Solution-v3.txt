This interoperability solution was needed to create an interoperable access control systems in a campus. The scenario is as follows:
A campus containing multiple buildings is using a couple of different access control systems to track entrance and exit of their employees , each building's access control system is chosen according to its security level. In each building, there is a secuity employee who is responsible for tracking the access control system. However for some buildings, they want secuity employee in a building to be able to track couple of buildings while locating in his/her original building. For example, security employee at Building A could track movement of employees of both Building A and Building B, and security employee at Building B could track movement of employees of both Building B and Building A. However as stated earlier, the access control systems installed in Building A and Building B could be different, so we have to forward each system activity between these buildings. To illustrate, access control system of Building A is publishing messages about the entrance to and exit from any toll gate to a topic named as "track" in its middleware, which is RabbitMQ. And access control system of Building B is publishing messages about the entrance to and exit from any toll gate to a topic named as "movement" in its middleware, which is Kafka. Both access control system is configurable to show employee movement, they can show data from various topics in their middlewares, e.g. access control system of Building A can show employee movement which is published on not just topic "track" but also from other topics, similarly for Building B's system. For this setup, we need to forward messages from "track" topic in RabbitMQ of Building A to Kafka of Building B with a topic name of our choice, we need to forward messages from "movement" topic in Kafka of Building B to RabbitMQ of Building A with a topic name of our choice. We are going to forward messages from "track" in RabbitMQ to "buildingA_movement" topic in Kafka, and forward messages from "movement" in Kafka to "buildingB_track" topic in RabbitMQ, and configure each access control system to show data also from these topics.
In short we need to forward messages published to some topics in both middlewares to each other. However there are different access control systems using different middleware solutions, and in the future there could be other systems to integrate together. That is why we needed a solution that is extensible to other middleware solutions, and configurable about which messages of which topics in which middleware should be forwarded to which topics in which middleware. And we come up with the following solution, seen in figure[coreGeneral.png].

//İMAGE
//İMAGE
//İMAGE
figure[coreGeneral.png]

Our solution for interoperability among different systems using different middleware technologies for their publish and subscribe operations consists of mainly three parts, which are :
	- Converter Configurator
	- Middleware Converters
	- Middleware, which will be named as middle broker from now on
	
We will use broker and middleware interchangeably.
	
	
3.1. Converter Configurator
-----------------------------------
There will be only one instance of Converter Configurator application for the whole interoperability systems. The main responsinility of the Converter Configurator is orchestrating the Middleware Converters. Converter Configurator serves a Rest API through which users of the interoperability tool can configure the which topics in which systems should be forwarded to which topics of which systems. There are three endpoints in the API, which are:

	- /registerConverter: The POST request accepted in this endpoint should have a request body which contains systemName, converterIP, converterPort, systemBrokerIP, systemBrokerPort parameters in json format. The Converter Configurator holds a map which has system names as key, and other system parameters as value, so Converter Configurator do not accept two converter with the same system name. converterIP and converterPort is used to send request to the Middleware Converter, systemBrokerIP and systemBrokerPort is used to make sure there is no more than one Middleware Converter connecting to the same middleware. This endpoint returns true if Middleware Converter can be added to the Converter Configurator, if not returns false.
	
	- /publishToMiddleBroker: The POST request accepted in this endpoint should have a request body which contains systemName, systemBrokerTopic, middleBrokerTopic parameters in json format. With systemName parameter, Converter Configurator decide which Middleware Converter is responsible for handling this request, then send a request to corresponding Middleware Converter's /publishToMiddle endpoint with request body containing systemBrokerTopic, middleBrokerTopic parameters. The Middleware Converter then, subscribes to systemBrokerTopic in the middleware the system uses, and every new message in this topic is published to middleBrokerTopic in the middleware we created for the interoperability system. At the end, Middleware Converter gets new messages from topic named as systemBrokerTopic from the system middleware, and published these messages to a topic named as middleBrokerTopic in the middle broker.
	
	- /subscribeToMiddleBroker: The POST request accepted in this endpoint should have a request body which contains systemName, middleBrokerTopic, systemBrokerTopic parameters in json format. With systemName parameter, Converter Configurator decide which Middleware Converter is responsible for handling this request, then send a request to corresponding Middleware Converter's /publishToSystem endpoint with request body containing middleBrokerTopic ,systemBrokerTopic parameters. The Middleware Converter then, subscribes to middleBrokerTopic in the middleware we created for the interoperability system, and every new message in this topic is published to systemBrokerTopic in the middleware the system uses. At the end, Middleware Converter gets new messages from topic named as middleBrokerTopic from middle broker, and publishes these messages to a topic named as systemBrokerTopic in the the system middleware.
	
	
3.2. Middleware Converter
-----------------------------------
The first thing Middleware Converter does when it starts to run is sending request to /registerManager endpoint of the Converter Configurator to let it know, it is up and ready to forward messages between middle broker and system broker.
The main responsibility of a Middleware Converter is to create connection to system middleware and interoperability system's middleware (middle broker) and store a mapping about which topic corresponds to which topic between these two middleware, and forward messages between them. It serves a Rest API through which Converter Configurator can configure it. There are two endpoints in the API, which are:

	- /publishToMiddle: The POST request accepted in this endpoint should have a request body which contains sysyemBrokerTopic, middleBrokerTopic parameters in json format. The Middleware Converter subscribes to topic given in the systemBrokerTopic parameter in the system middleware and publishes the new messages to the topic given in the middleBrokerTopic parameter in the middle broker.
	
	- /publishToSystem: The POST request accepted in this endpoint should have a request body which contains middleBrokerTopic, systemBrokerTopic parameters in json format. The Middleware Converter subscribes to topic given in the middleBrokerTopic parameter in the middle broker and publishes the new messages to the topic given in the systemBrokerTopic parameter in the system middleware.
	
	
3.2. Middleware (Middle Broker)
-----------------------------------
The forwarding of messages among different systems is a very diffucult task to handle, since it is not known in advance messages in which topics in which system middlewares will be sent to which topics in which system middlewares. This mapping has not to be one-to-one. For example, we can map "track" in Building A's access control system to "buildingA_movement" in Building B's access control system and also "track" in Building A's access control system to "buildingA_entrance_exit" in Building C's access control system. In short, our interoperability tool should be like a middleware in itself, which lets multiple publishers and subscribers for a topic. That is why we decided it is best to use a off-the-shelf application to handle these tasks for us, and we choose to use RabbitMQ as our middle middleware. It handles all the hard job for us. 
Let's look at the previous example, it is like,
	* "track" in Building A -> "buildingA_movement" in Building B and
	* "track" in Building A -> "buildingA_entrance_exit" in Building C
In this case, Building A's Middleware Converter just publishes messages of "track" topic in Building A's middleware to a topic, whose name is given by the user of the interoperability tool, in the middle broker, let's named it as "buildingA_track_middle" for now. After that, Building B's Middleware Converter subscribes "buildingA_track_middle" topic in the middle broker and publishes messages to "buildingA_movement" topic in Building B's middleware. And Building C's Middleware Converter subscribes "buildingA_track_middle" topic in middle broker and publishes messages to "buildingA_entrance_exit" topic in Building C's middleware.